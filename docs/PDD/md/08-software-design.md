# High-Level Software/Firmware Design

<!-- For each software/firmware component in the architecture, describe its
implementation and how it is related to other components. 1 page max -->

The most abstract explanation of the software aspect of the project would be
that a fysh program is compiled by the custom fysh compiler and executed on our
hardware. More in depth, the compiler consists of multiple components which
break down the fysh program so that it can be understood and executed using C++. The first piece of this compiler is the front end, which is made up of the lexer and the parser. The lexer takes in fysh code as input,
and turns it into a series of tokens, i.e tokenizes, which the parser can then interpret. The
parser takes a sequence of tokens from the lexer and produces an AST of
the program. From here we enter the middle end of the compiler, where the semantic analyzer traverses the syntax tree generated by the parser and checks if the program is semantically consistent. From here the remaining components of the middle end of the  compiler are considered optional for our implementation, but they are based on LLVM/GCC infrastructure and consist of an intermediate representation and optimization passes. An intermediate representation is essentially a data structure representing source code, which may then be subjected to several optomization passes, some for analyzing, some for transforming, and other additional utility optimizations. Before moving on to the back end, we note once again that since the LLVM/GCC stage of the middle end is listed as optional, the compiler may move straight from semantic analysis to the back end. The back end of the compiler contains the code generation aspect of our compiler, which processes source code into machine code so that it can be executed by the user.
