# High-Level Software/Firmware Design

The most abstract explanation of the software aspect of the project would be
that a Fysh program is compiled by the custom Fysh compiler and executed on our
hardware. More in depth, the compiler consists of multiple components which
break down the Fysh program so that it can be understood and executed using C++.

The first piece of this compiler is the front end, which is made up of the lexer
(**FyshLexer**), the parser (**FyshParser**), and the **semantic analyzer**. The
Fyshlexer takes in Fysh code as input, and turns it into a series of tokens, i.e
tokenizes, which the parser can then interpret. The parser takes a sequence of
tokens from the lexer and produces an AST of the program while checking its
syntax. Next the semantic analyzer traverses the syntax tree generated by the
parser and checks if the program is semantically consistent.

From here we move on to the middle end of the compiler, which includes the
**intermediate representation** and **optimization passes**, which are
considered optional for our implementation. An intermediate representation is
essentially a data structure representing source code, which may then be
subjected to several optomization passes, some for analyzing, some for
transforming, and other additional utility optimizations. Before moving on to
the back end, we note once again that since the middle end is listed as
optional, the compiler may move straight from semantic analysis to the back end.

The back end of the compiler contains the **code generation** aspect of our
compiler, which processes source code into machine code so that it can be
executed by the user.
